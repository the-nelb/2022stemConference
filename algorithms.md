# Algorithms


## Think-Do cycle
Humans solve problems by iterating through a two-step process:
1. they <em>think</em> about situation before them and determine the next action; then,
2. they *do* that action, which changes the situation before them, and they go back to step 1.


<!-- .slide: data-auto-animate -->
They keep doing this until the problem is complete.

- <!-- .element: class="fragment" --><em>think</em>
- <!-- .element: class="fragment" --><strong>do</strong>
- <!-- .element: class="fragment" --><em>think</em>
- <!-- .element: class="fragment" --><strong>do</strong>
- <!-- .element: class="fragment" --><em>think</em>
- <!-- .element: class="fragment" --><strong>do</strong>
- <!-- .element: class="fragment" --><em>think</em>
- <!-- .element: class="fragment" --><strong>do</strong>


<!-- .slide: data-auto-animate -->
The process of automating a system (identifying an algorithm and turning it into a program) involves separating all the thinking steps from the doing steps.

- <em>think</em>
- <strong>do</strong>
- <em>think</em>
- <strong>do</strong>
- <em>think</em>
- <strong>do</strong>
- <em>think</em>
- <strong>do</strong>


<!-- .slide: data-auto-animate -->
The process of automating a system (identifying an algorithm and turning it into a program) involves separating all the thinking steps from the doing steps.

- <em>think</em>
- <em>think</em>
- <em>think</em>
- <em>think</em>
- <strong>do</strong>
- <strong>do</strong>
- <strong>do</strong>
- <strong>do</strong>


<!-- .slide: data-auto-animate -->
### Algorithm
- <em>think</em>
- <em>think</em>
- <em>think</em>
- <em>think</em>

### Execution
- <strong>do</strong>
- <strong>do</strong>
- <strong>do</strong>
- <strong>do</strong>


<!-- .slide: data-auto-animate -->
### Algorithm
*Only has to be figured out once. Can then be reused infinitely.*

### Execution
*Can now happen at machine/computer speed, with no waiting for those slow humans.*


<!-- .slide: data-auto-animate -->
### Algorithm
We (eventually) need to anticipate *every* possible input and scenario, or else the program will do the wrong thing (or crash). This is the challenge (and fun) of algorithm design.


### Algorithm vs. Program
An **algorithm** is the *series of actions and decisions* required to solve a problem or perform a task.

A **program** is an algorithm which has been *expressed in a programming language*, and is ready to give to a *machine to execute*.


An algorithm can be expressed:
- in a natural language (like English or Hindi),
- graphically (like a flowchart),
- in a structured formal language (like pseudocode or mathematics),
- in a programming language (like Python, JavaScript, or Scratch).
